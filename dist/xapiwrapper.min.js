var _this = this;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {},

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }();

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                    thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push(Math.random() * 0x100000000 | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };
    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
                var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;

                var triplet = byte1 << 16 | byte2 << 8 | byte3;

                for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                    base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;
                    words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512 / 32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = n << 1 | n >>> 31;
                }

                var t = (a << 5 | a >>> 27) + e + W[i];
                if (i < 20) {
                    t += (b & c | ~b & d) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += (b & c | b & d | c & d) - 0x70e44324;
                } else /* if (i < 80) */{
                        t += (b ^ c ^ d) - 0x359d3e2a;
                    }

                e = d;
                d = c;
                c = b << 30 | b >>> 2;
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);

    return C;
}(Math);

//add the sha256 functions

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS = CryptoJS || function (h, s) {
    var f = {},
        g = f.lib = {},
        q = function () {},
        m = g.Base = { extend: function (a) {
            q.prototype = this;var c = new q();a && c.mixIn(a);c.hasOwnProperty("init") || (c.init = function () {
                c.$super.init.apply(this, arguments);
            });c.init.prototype = c;c.$super = this;return c;
        }, create: function () {
            var a = this.extend();a.init.apply(a, arguments);return a;
        }, init: function () {}, mixIn: function (a) {
            for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);a.hasOwnProperty("toString") && (this.toString = a.toString);
        }, clone: function () {
            return this.init.prototype.extend(this);
        } },
        r = g.WordArray = m.extend({ init: function (a, c) {
            a = this.words = a || [];this.sigBytes = c != s ? c : 4 * a.length;
        }, toString: function (a) {
            return (a || k).stringify(this);
        }, concat: function (a) {
            var c = this.words,
                d = a.words,
                b = this.sigBytes;a = a.sigBytes;this.clamp();if (b % 4) for (var e = 0; e < a; e++) c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4);else if (65535 < d.length) for (e = 0; e < a; e += 4) c[b + e >>> 2] = d[e >>> 2];else c.push.apply(c, d);this.sigBytes += a;return this;
        }, clamp: function () {
            var a = this.words,
                c = this.sigBytes;a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);a.length = h.ceil(c / 4);
        }, clone: function () {
            var a = m.clone.call(this);a.words = this.words.slice(0);return a;
        }, random: function (a) {
            for (var c = [], d = 0; d < a; d += 4) c.push(4294967296 * h.random() | 0);return new r.init(c, a);
        } }),
        l = f.enc = {},
        k = l.Hex = { stringify: function (a) {
            var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) {
                var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;d.push((e >>> 4).toString(16));d.push((e & 15).toString(16));
            }return d.join("");
        }, parse: function (a) {
            for (var c = a.length, d = [], b = 0; b < c; b += 2) d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);return new r.init(d, c / 2);
        } },
        n = l.Latin1 = { stringify: function (a) {
            var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));return d.join("");
        }, parse: function (a) {
            for (var c = a.length, d = [], b = 0; b < c; b++) d[b >>> 2] |= (a.charCodeAt(b) & 255) << 24 - 8 * (b % 4);return new r.init(d, c);
        } },
        j = l.Utf8 = { stringify: function (a) {
            try {
                return decodeURIComponent(escape(n.stringify(a)));
            } catch (c) {
                throw Error("Malformed UTF-8 data");
            }
        }, parse: function (a) {
            return n.parse(unescape(encodeURIComponent(a)));
        } },
        u = g.BufferedBlockAlgorithm = m.extend({ reset: function () {
            this._data = new r.init();this._nDataBytes = 0;
        }, _append: function (a) {
            "string" == typeof a && (a = j.parse(a));this._data.concat(a);this._nDataBytes += a.sigBytes;
        }, _process: function (a) {
            var c = this._data,
                d = c.words,
                b = c.sigBytes,
                e = this.blockSize,
                f = b / (4 * e),
                f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);a = f * e;b = h.min(4 * a, b);if (a) {
                for (var g = 0; g < a; g += e) this._doProcessBlock(d, g);g = d.splice(0, a);c.sigBytes -= b;
            }return new r.init(g, b);
        }, clone: function () {
            var a = m.clone.call(this);
            a._data = this._data.clone();return a;
        }, _minBufferSize: 0 });g.Hasher = u.extend({ cfg: m.extend(), init: function (a) {
            this.cfg = this.cfg.extend(a);this.reset();
        }, reset: function () {
            u.reset.call(this);this._doReset();
        }, update: function (a) {
            this._append(a);this._process();return this;
        }, finalize: function (a) {
            a && this._append(a);return this._doFinalize();
        }, blockSize: 16, _createHelper: function (a) {
            return function (c, d) {
                return new a.init(d).finalize(c);
            };
        }, _createHmacHelper: function (a) {
            return function (c, d) {
                return new t.HMAC.init(a, d).finalize(c);
            };
        } });var t = f.algo = {};return f;
}(Math);
(function (h) {
    for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function (a) {
        return 4294967296 * (a - (a | 0)) | 0;
    }, k = 2, n = 0; 64 > n;) {
        var j;a: {
            j = k;for (var u = h.sqrt(j), t = 2; t <= u; t++) if (!(j % t)) {
                j = !1;break a;
            }j = !0;
        }j && (8 > n && (m[n] = l(h.pow(k, 0.5))), r[n] = l(h.pow(k, 1 / 3)), n++);k++;
    }var a = [],
        f = f.SHA256 = q.extend({ _doReset: function () {
            this._hash = new g.init(m.slice(0));
        }, _doProcessBlock: function (c, d) {
            for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; 64 > p; p++) {
                if (16 > p) a[p] = c[d + p] | 0;else {
                    var k = a[p - 15],
                        l = a[p - 2];a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];
                }k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p];l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g);q = n;n = m;m = h;h = j + k | 0;j = g;g = f;f = e;e = k + l | 0;
            }b[0] = b[0] + e | 0;b[1] = b[1] + f | 0;b[2] = b[2] + g | 0;b[3] = b[3] + j | 0;b[4] = b[4] + h | 0;b[5] = b[5] + m | 0;b[6] = b[6] + n | 0;b[7] = b[7] + q | 0;
        }, _doFinalize: function () {
            var a = this._data,
                d = a.words,
                b = 8 * this._nDataBytes,
                e = 8 * a.sigBytes;
            d[e >>> 5] |= 128 << 24 - e % 32;d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296);d[(e + 64 >>> 9 << 4) + 15] = b;a.sigBytes = 4 * d.length;this._process();return this._hash;
        }, clone: function () {
            var a = q.clone.call(this);a._hash = this._hash.clone();return a;
        } });s.SHA256 = q._createHelper(f);s.HmacSHA256 = q._createHmacHelper(f);
})(Math);
(function () {
    var h = CryptoJS,
        s = h.enc.Utf8;h.algo.HMAC = h.lib.Base.extend({ init: function (f, g) {
            f = this._hasher = new f.init();"string" == typeof g && (g = s.parse(g));var h = f.blockSize,
                m = 4 * h;g.sigBytes > m && (g = f.finalize(g));g.clamp();for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; j < h; j++) k[j] ^= 1549556828, n[j] ^= 909522486;r.sigBytes = l.sigBytes = m;this.reset();
        }, reset: function () {
            var f = this._hasher;f.reset();f.update(this._iKey);
        }, update: function (f) {
            this._hasher.update(f);return this;
        }, finalize: function (f) {
            var g = this._hasher;f = g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f));
        } });
})();

{

    let debug = true;
    let onBrowser = true;

    if (typeof module !== 'undefined') {
        onBrowser = false;
        var request = require('request');
        var Util = require('./Utils.js');
    } else {
        window.ADL = window.ADL || {};
        var Util = window.ADL.Util;
        var request = fetch;
    }

    /*
     * Config object used w/ url params to configure the lrs object
     * change these to match your lrs
     * @return {object} config object
     * @example
     * let conf = {
     *    "endpoint" : "https://lrs.adlnet.gov/xapi/",
     *    "auth" : `Basic ${Util.toBase64('tom:1234')}`,
     * };
     * XAPIWrapper.changeConfig(conf);
     */
    let Config = (() => {
        let conf = {};
        conf['endpoint'] = "https://lrs.adlnet.gov/xapi/";
        try {
            conf['auth'] = `Basic ${Util.toBase64('tom:1234')}`;
        } catch (e) {
            console.log(`Exception in Config trying to encode auth: ${e}`);
        }

        // Statement defaults
        // conf["actor"] = {"mbox":"default@example.com"};
        // conf["registration"] =  Util.ruuid();
        // conf["grouping"] = {"id":"ctxact:default/grouping"};
        // conf["activity_platform"] = "default platform";
        return conf;
    })();

    class XAPIWrapper {
        /*
         * XAPIWrapper Constructor
         * @param {object} config   with a minimum of an endoint property
         * @param {boolean} verifyxapiversion   indicating whether to verify the version of the LRS is compatible with this wrapper
         */
        constructor(config, verifyxapiversion) {
            this.lrs = this.getLRSObject(config || {});

            if (this.lrs.user && this.lrs.password) updateAuth(this.lrs, this.lrs.user, this.lrs.password);
            this.base = getbase(this.lrs.endpoint);

            this.withCredentials = false;
            this.withCredentials = config && config.withCredentials;

            // Ensure that callbacks are always executed, first param is error (null if no error) followed
            // by the result(s)
            this.strictCallbacks = false;
            this.strictCallbacks = config && config.strictCallbacks;

            function getbase(url) {
                if (!onBrowser) return;

                let l = document.createElement("a");
                l.href = url;

                if (l.protocol && l.host) return `${l.protocol}//${l.host}`;

                this.log(`Couldn't create base url from endpoint: ${url}`);
            }

            function updateAuth(obj, username, password) {
                obj.auth = `Basic ${Util.toBase64(`${username}:${password}`)}`;
            }

            // if (verifyxapiversion && testConfig.call(this))
            // {
            //     XHR_request(this.lrs, `${this.lrs.endpoint}about`, "GET", null, null,
            //         r => {
            //             if(r.status == 200)
            //             {
            //                 try
            //                 {
            //                     let lrsabout = JSON.parse(r.response);
            //                     let versionOK = false;
            //                     for (let idx in lrsabout.version)
            //                     {
            //                         if(lrsabout.version[idx] == this.xapiVersion)
            //                         {
            //                             versionOK = true;
            //                             break;
            //                         }
            //                     }
            //                     if (!versionOK)
            //                     {
            //                         log(`The lrs version [${lrsabout.version}] does not match this wrapper's XAPI version [${this.xapiVersion}]`);
            //                     }
            //                 }
            //                 catch(e)
            //                 {
            //                     log("The response was not an about object")
            //                 }
            //             }
            //             else
            //             {
            //                 log(`The request to get information about the LRS failed: ${r}`);
            //             }
            //         },null,false,null,this.withCredentials, false);
            // }

            this.searchParams = () => {
                return { "format": "exact" };
            };

            this.hash = tohash => {
                if (!tohash) return null;
                try {
                    return Util.toSHA1(tohash);
                } catch (e) {
                    this.log(`Error trying to hash -- ${e}`);
                    return null;
                }
            };

            this.changeConfig = config => {
                try {
                    this.lrs = this.mergeRecursive(this.lrs, config);
                    if (config.user && config.password) updateAuth(this.lrs, config.user, config.password);
                    this.base = getbase(this.lrs.endpoint);
                    this.withCredentials = config.withCredentials;
                    this.strictCallbacks = config.strictCallbacks;
                } catch (e) {
                    this.log(`error while changing configuration -- ${e}`);
                }
            };

            this.updateAuth = updateAuth;
            this.xapiVersion = "1.0.3";
        }

        /*
         * Adds info from the lrs object to the statement, if available.
         * These values could be initialized from the Config object or from the url query string.
         * @param {object} stmt   the statement object
         */
        prepareStatement(stmt) {
            if (stmt.actor === undefined) {
                stmt.actor = JSON.parse(this.lrs.actor);
            } else if (typeof stmt.actor === "string") {
                stmt.actor = JSON.parse(stmt.actor);
            }
            if (this.lrs.grouping || this.lrs.registration || this.lrs.activity_platform) {
                if (!stmt.context) {
                    stmt.context = {};
                }
            }

            if (this.lrs.grouping) {
                if (!stmt.context.contextActivities) {
                    stmt.context.contextActivities = {};
                }
                stmt.context.contextActivities.grouping = [{ id: this.lrs.grouping }];
            }
            if (this.lrs.registration) {
                stmt.context.registration = this.lrs.registration;
            }
            if (this.lrs.activity_platform) {
                stmt.context.platform = this.lrs.activity_platform;
            }
        }

        /*
        * Build the post body to include the multipart boundries, edit the statement to include the attachment types
        * extraHeaders should be an object. It will have the multipart boundary value set
        * attachments should be an array of objects of the type
        * {
              type:"signature" || {
                usageType : URI,
                display: Language-map
                description: Language-map
              },
              value : a UTF8 string containing the binary data of the attachment. For string values, this can just be the JS string.
           }
        */
        buildMultipart(statement, attachments, extraHeaders) {
            statement.attachments = [];
            for (let i = 0; i < attachments.length; i++) {
                //replace the term 'signature' with the hard coded definition for a signature attachment
                if (attachments[i].type == "signature") {
                    attachments[i].type = {
                        "usageType": "http://adlnet.gov/expapi/attachments/signature",
                        "display": {
                            "en-US": "A JWT signature"
                        },
                        "description": {
                            "en-US": "A signature proving the statement was not modified"
                        },
                        "contentType": "application/octet-stream"
                    };
                }

                //compute the length and the sha2 of the attachment
                attachments[i].type.length = attachments[i].value.length;
                attachments[i].type.sha2 = Util.toSHA256(attachments[i].value);

                //attach the attachment metadata to the statement
                statement.attachments.push(attachments[i].type);
            }

            let body = "";
            let CRLF = "\r\n";
            let boundary = `${Math.random()} `.substring(2, 10) + `${Math.random()} `.substring(2, 10);

            extraHeaders["Content-Type"] = `multipart/mixed; boundary=${boundary}`;

            body += `${CRLF}--${boundary}${CRLF}Content-Type:application/json${CRLF}Content-Disposition: form-data; name=\"statement\"${CRLF}${CRLF}`;
            body += JSON.stringify(statement);

            for (let i in attachments) {
                body += `${CRLF}--${boundary}${CRLF}X-Experience-API-Hash:${attachments[i].type.sha2}${CRLF}Content-Type:application/octet-stream${CRLF}Content-Transfer-Encoding: binary${CRLF}${CRLF}`;
                body += attachments[i].value;
            }
            body += `${CRLF}--${boundary}--${CRLF}`;

            return body;
        }

        /*
         * Send a single statement to the LRS using a PUT request.
         * @param {object} stmt   statement object to send
         * @param {string} id   id of the statement object to send
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         *            and an object with an id property assigned the id
         *            of the statement
         * @return {object} object containing xhr object and id of statement
         */
        putStatement(stmt, id, callback, attachments) {
            if (this.testConfig() && stmt && !(stmt instanceof Array) && id && stmt.id == id) {
                this.prepareStatement(stmt);
                stmt.id = id;

                let payload = JSON.stringify(stmt);
                let extraHeaders = null;
                if (attachments && attachments.length > 0) {
                    extraHeaders = {};
                    payload = this.buildMultipart(stmt, attachments, extraHeaders);
                }

                if (callback) {
                    this.defaultRequest(this.lrs, `${this.lrs.endpoint}statements?statementId=${id}`, "PUT", payload, this.lrs.auth, callback, { id }, null, extraHeaders, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url: `${this.lrs.endpoint}statements?statementId=${id}`,
                    'method': 'PUT',
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth },
                    'body': payload };

                if (extraHeaders) {
                    for (let headerName in extraHeaders) {
                        conf.headers[headerName] = extraHeaders[headerName];
                    }
                }

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Send a single statement to the LRS using a POST request.
         * Makes a Javascript object with the statement id as 'id' available to the callback function.
         * @param {object} stmt   statement object to send
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         *            and an object with an id property assigned the id
         *            of the statement
         * @return {object} object containing xhr object and id of statement
         */
        postStatement(stmt, callback, attachments) {
            if (this.testConfig() && stmt && !(stmt instanceof Array)) {
                this.prepareStatement(stmt);

                let payload = JSON.stringify(stmt);
                let extraHeaders = null;
                if (attachments && attachments.length > 0) {
                    extraHeaders = {};
                    payload = this.buildMultipart(stmt, attachments, extraHeaders);
                }

                if (callback) {
                    this.defaultRequest(this.lrs, `${this.lrs.endpoint}statements`, "POST", payload, this.lrs.auth, callback, { 'id': stmt.id }, null, extraHeaders, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url: `${this.lrs.endpoint}statements`,
                    'method': 'POST',
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth },
                    'body': payload };

                if (extraHeaders) {
                    for (let headerName in extraHeaders) {
                        conf.headers[headerName] = extraHeaders[headerName];
                    }
                }

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Send a list of statements to the LRS.
         * @param {array} stmtArray   the list of statement objects to send
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object
         * @example
         * let stmt = {"actor" : {"mbox" : "mailto:tom@example.com"},
         *             "verb" : {"id" : "http://adlnet.gov/expapi/verbs/answered",
         *                       "display" : {"en-US" : "answered"}},
         *             "object" : {"id" : "http://adlnet.gov/expapi/activities/question"}};
         * let resp_obj = XAPIWrapper.postStatement(stmt);
         * XAPIWrapper.getStatements({"statementId":resp_obj.id});
         * >> {"version": "1.0.0",
         *     "timestamp": "2013-09-09 21:36:40.185841+00:00",
         *     "object": {"id": "http://adlnet.gov/expapi/activities/question", "objectType": "Activity"},
         *     "actor": {"mbox": "mailto:tom@example.com", "name": "tom creighton", "objectType": "Agent"},
         *     "stored": "2013-09-09 21:36:40.186124+00:00",
         *     "verb": {"id": "http://adlnet.gov/expapi/verbs/answered", "display": {"en-US": "answered"}},
         *     "authority": {"mbox": "mailto:tom@adlnet.gov", "name": "tom", "objectType": "Agent"},
         *     "context": {"registration": "51a6f860-1997-11e3-8ffd-0800200c9a66"},
         *     "id": "ea9c1d01-0606-4ec7-8e5d-20f87b1211ed"}
         */
        postStatements(stmtArray, callback) {
            if (this.testConfig() && stmtArray && stmtArray instanceof Array && stmtArray.length > 0) {
                for (let i in stmtArray) {
                    this.prepareStatement(stmtArray[i]);
                }

                if (callback) {
                    this.defaultRequest(this.lrs, `${this.lrs.endpoint}statements`, "POST", JSON.stringify(stmtArray), this.lrs.auth, callback, null, false, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url: `${this.lrs.endpoint}statements`,
                    'method': 'POST',
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth },
                    'body': JSON.stringify(stmtArray) };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Get statement(s) based on the searchparams or more url.
         * @param {object} searchparams   an XAPIWrapper.searchParams object of
         *                key(search parameter)-value(parameter value) pairs.
         *                Example:
         *                  let myparams = XAPIWrapper.searchParams();
         *                  myparams['verb'] = verbs.completed.id;
         *                  let completedStmts = XAPIWrapper.getStatements(myparams);
         * @param {string} more   the more url found in the StatementResults object, if there are more
         *        statements available based on your get statements request. Pass the
         *        more url as this parameter to retrieve those statements.
         * @param {function} [callback] - function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * let ret = XAPIWrapper.getStatements();
         * if (ret)
         *     XAPIWrapper.log(ret.statements);
         *
         * >> <Array of statements>
         */
        getStatements(searchparams, more, callback) {
            if (this.testConfig()) {
                let url = `${this.lrs.endpoint}statements`;
                if (more) {
                    url = this.base + more;
                } else if (searchparams) {
                    let urlparams = new Array();

                    for (let s in searchparams) {
                        if (s == "until" || s == "since") {
                            let d = new Date(searchparams[s]);
                            urlparams.push(`${s}=${encodeURIComponent(d.toISOString())}`);
                        } else {
                            urlparams.push(`${s}=${encodeURIComponent(searchparams[s])}`);
                        }
                    }
                    if (urlparams.length > 0) url = `${url}?${urlparams.join("&")}`;
                }

                if (callback) {
                    this.defaultRequest(this.lrs, url, "GET", null, this.lrs.auth, callback, null, false, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url,
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth } };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        getMoreStatements(iterations, callback, searchParams) {
            if (!onBrowser) throw new Error("Node not supported.");

            let stmts = [];

            this.getStatements(searchParams, null, getMore = r => {
                if (!(r && r.response)) return;
                let res = JSON.parse(r.response);
                if (!res.statements) return;
                stmts = stmts.concat(res.statements);

                if (iterations-- <= 0) {
                    callback(stmts);
                } else {
                    if (res.more && res.more !== "") {
                        this.getStatements(searchParams, res.more, getMore);
                    } else if (res.more === "") {
                        callback(stmts);
                    }
                }
            });
        }

        /*
         * Update activity state in the LRS
         * @param {string} activityid   the id of the Activity this state is about
         * @param {object} agent   the agent this Activity state is related to
         * @param {string} stateid   the id you want associated with this state
         * @param {string} [registration]   the registraton id associated with this state
         * @param {string} stateval   the state
         * @param {string} [matchHash]    the hash of the state to replace or * to replace any
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {boolean} false if no activity state is included
         */
        putState(activityid, agent, stateid, registration, stateval, matchHash, callback) {
            if (this.testConfig() && stateval && activityid && agent && stateid) {
                if (!matchHash || matchHash == "") matchHash = '*';

                let url = `${this.lrs.endpoint}activities/state?activityId=${activityid}&agent=${JSON.stringify(agent)}&stateId=${stateid}`;

                if (registration) url += `&registration=${encodeURIComponent(registration)}`;

                let headers = { "If-Match": `"${matchHash}"` };
                if (stateval instanceof Array || stateval instanceof Object) {
                    stateval = JSON.stringify(stateval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                if (callback) {
                    this.defaultRequest(this.lrs, url, "PUT", stateval, this.lrs.auth, callback, null, null, headers, this.withCredentials, this.strictCallbacks);
                    return;
                }

                headers['X-Experience-API-Version'] = this.xapiVersion;
                headers['Authorization'] = this.lrs.auth;

                const conf = { url, 'method': 'PUT', headers, 'body': stateval };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Store activity state in the LRS
         * @param {string} activityid   the id of the Activity this state is about
         * @param {object} agent   the agent this Activity state is related to
         * @param {string} stateid   the id you want associated with this state
         * @param {string} [registration]   the registraton id associated with this state
         * @param {string} stateval   the state
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {boolean} false if no activity state is included
         */
        postState(activityid, agent, stateid, registration, stateval, callback) {
            if (this.testConfig() && stateval && activityid && agent && stateid) {
                let url = `${this.lrs.endpoint}activities/state?activityId=${activityid}&agent=${JSON.stringify(agent)}&stateId=${stateid}`;

                if (registration) url += `&registration=${encodeURIComponent(registration)}`;

                let headers = {};
                if (stateval instanceof Array || stateval instanceof Object) {
                    stateval = JSON.stringify(stateval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                if (callback) {
                    this.defaultRequest(this.lrs, url, "POST", stateval, this.lrs.auth, callback, null, null, headers, this.withCredentials, this.strictCallbacks);
                    return;
                }

                headers['X-Experience-API-Version'] = this.xapiVersion;
                headers['Authorization'] = this.lrs.auth;

                const conf = { url, 'method': 'POST', headers, 'body': stateval };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Get activity state from the LRS
         * @param {string} activityid   the id of the Activity this state is about
         * @param {object} agent   the agent this Activity state is related to
         * @param {string} [stateid]    the id of the state, if not included, the response will be a list of stateids
         *            associated with the activity and agent)
         * @param {string} [registration]   the registraton id associated with this state
         * @param {object} [since]    date object or date string telling the LRS to return objects newer than the date supplied
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * XAPIWrapper.getState("http://adlnet.gov/expapi/activities/question",
         *                  {"mbox":"mailto:tom@example.com"}, "questionstate");
         * >> {info: "the state info"}
         */
        getState(activityid, agent, stateid, registration, since, callback) {
            if (this.testConfig() && activityid && agent) {
                let url = `${this.lrs.endpoint}activities/state?activityId=${activityid}&agent=${JSON.stringify(agent)}`;

                if (stateid) {
                    url += `&stateId=${encodeURIComponent(stateid)}`;
                }

                if (registration) {
                    url += `&registration=${encodeURIComponent(registration)}`;
                }

                if (since) {
                    since = Util.isDate(since);
                    if (since != null) {
                        url += `&since=${encodeURIComponent(since.toISOString())}`;
                    }
                }

                if (callback) {
                    this.defaultRequest(this.lrs, url, "GET", null, this.lrs.auth, callback, null, true, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url,
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth } };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Delete activity state in the LRS
         * @param {string} activityid   the id of the Activity this state is about
         * @param {object} agent   the agent this Activity state is related to
         * @param {string} [stateid]   the id you want associated with this state
         * @param {string} [registration]   the registraton id associated with this state
         * @param {string} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * let stateval = {"info":"the state info"};
         * XAPIWrapper.postState("http://adlnet.gov/expapi/activities/question",
         *                           {"mbox":"mailto:tom@example.com"},
         *                           "questionstate", null, stateval);
         * XAPIWrapper.getState("http://adlnet.gov/expapi/activities/question",
         *                         {"mbox":"mailto:tom@example.com"}, "questionstate");
         * >> {info: "the state info"}
         *
         * XAPIWrapper.deleteState("http://adlnet.gov/expapi/activities/question",
         *                         {"mbox":"mailto:tom@example.com"}, "questionstate");
         * >> XMLHttpRequest {statusText: "NO CONTENT", status: 204, response: "", responseType: "", responseXML: null}
         *
         * XAPIWrapper.getState("http://adlnet.gov/expapi/activities/question",
         *                         {"mbox":"mailto:tom@example.com"}, "questionstate");
         * >> 404
         */
        deleteState(activityid, agent, stateid, registration, callback) {
            if (this.testConfig() && activityid && agent) {
                let url = `${this.lrs.endpoint}activities/state?activityId=${activityid}&agent=${JSON.stringify(agent)}`;

                if (stateid) {
                    url += `&stateId=${encodeURIComponent(stateid)}`;
                }

                if (registration) {
                    url += `&registration=${encodeURIComponent(registration)}`;
                }

                if (callback) {
                    this.defaultRequest(this.lrs, url, "DELETE", null, this.lrs.auth, callback, null, null, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url,
                    'method': "DELETE",
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth } };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Gets the Activity object from the LRS.
         * @param {string} activityid   the id of the Activity to get
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * let res = XAPIWrapper.getActivities("http://adlnet.gov/expapi/activities/question");
         * XAPIWrapper.log(res);
         * >> <Activity object>
         */
        getActivities(activityid, callback) {
            if (this.testConfig() && activityid) {
                let url = `${this.lrs.endpoint}activities?activityId=${activityid}`;

                if (callback) {
                    this.defaultRequest(this.lrs, url, "GET", null, this.lrs.auth, callback, null, true, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url,
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth } };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Update activity profile in the LRS
         * @param {string} activityid   the id of the Activity this profile is about
         * @param {string} profileid   the id you want associated with this state
         * @param {string} profileval   the profile
         * @param {string} [matchHash]    the hash of the state to replace or * to replace any
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {boolean} false if no activity state is included
         */
        putActivityProfile(activityid, profileid, profileval, matchHash, callback) {
            if (this.testConfig()) {
                if (!profileval) return false;

                if (!matchHash || matchHash == "") matchHash = '*';

                let url = `${this.lrs.endpoint}activities/profile?activityId=<activity ID>&profileId=<profileid>`;

                url = url.replace('<activity ID>', encodeURIComponent(activityid));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                let headers = { "If-Match": `"${matchHash}"` };
                if (profileval instanceof Array || profileval instanceof Object) {
                    profileval = JSON.stringify(profileval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                XHR_request(this.lrs, url, "PUT", profileval, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);
            }
        }

        /*
         * Store activity profile in the LRS
         * @param {string} activityid   the id of the Activity this profile is about
         * @param {string} profileid   the id you want associated with this state
         * @param {string} profileval   the profile
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {boolean} false if no activity state is included
         */
        postActivityProfile(activityid, profileid, profileval, callback) {
            if (this.testConfig() && profileval && activityid && profileid) {
                let url = `${this.lrs.endpoint}activities/profile?activityId=${activityid}&profileId=${profileid}`;

                let headers = {};
                if (profileval instanceof Array || profileval instanceof Object) {
                    profileval = JSON.stringify(profileval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                if (callback) {
                    this.defaultRequest(this.lrs, url, "POST", profileval, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);
                    return;
                }

                headers['X-Experience-API-Version'] = this.xapiVersion;
                headers['Authorization'] = this.lrs.auth;

                const conf = { url, 'method': 'POST', headers, 'body': profileval };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Get activity profile from the LRS
         * @param {string} activityid   the id of the Activity this profile is about
         * @param {string} [profileid]    the id of the profile, if not included, the response will be a list of profileids
         *              associated with the activity
         * @param {object} [since]    date object or date string telling the LRS to return objects newer than the date supplied
         * @param {function [callback]    function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * XAPIWrapper.getActivityProfile("http://adlnet.gov/expapi/activities/question",
         *                                    "actprofile", null,
         *                                    function(r){XAPIWrapper.log(JSON.parse(r.response));});
         * >> {info: "the profile"}
         */
        getActivityProfile(activityid, profileid, since, callback) {
            if (this.testConfig()) {
                let url = `${this.lrs.endpoint}activities/profile?activityId=<activity ID>`;

                url = url.replace('<activity ID>', encodeURIComponent(activityid));

                if (profileid) {
                    url += `&profileId=${encodeURIComponent(profileid)}`;
                }

                if (since) {
                    since = Util.isDate(since);
                    if (since != null) {
                        url += `&since=${encodeURIComponent(since.toISOString())}`;
                    }
                }

                let result = XHR_request(this.lrs, url, "GET", null, this.lrs.auth, callback, null, true, null, this.withCredentials, this.strictCallbacks);

                if (result === undefined || result.status == 404) {
                    return null;
                }

                try {
                    return JSON.parse(result.response);
                } catch (e) {
                    return result.response;
                }
            }
        }

        /*
         * Delete activity profile in the LRS
         * @param {string} activityid   the id of the Activity this profile is about
         * @param {string} profileid   the id you want associated with this profile
         * @param {string} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * XAPIWrapper.deleteActivityProfile("http://adlnet.gov/expapi/activities/question",
         *                                       "actprofile");
         * >> XMLHttpRequest {statusText: "NO CONTENT", status: 204, response: "", responseType: "", responseXML: null}
         */
        deleteActivityProfile(activityid, profileid, callback) {
            if (this.testConfig()) {
                let url = `${this.lrs.endpoint}activities/profile?activityId=<activity ID>&profileId=<profileid>`;

                url = url.replace('<activity ID>', encodeURIComponent(activityid));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                let headers = null;
                let result = XHR_request(this.lrs, url, "DELETE", null, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);

                if (result === undefined || result.status == 404) {
                    return null;
                }

                try {
                    return JSON.parse(result.response);
                } catch (e) {
                    return result;
                }
            }
        }

        /*
         * Gets the Person object from the LRS based on an agent object.
         * The Person object may contain more information about an agent.
         * See the xAPI Spec for details.
         * @param {object} agent   the agent object to get a Person
         * @param {function [callback]    function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * let res = XAPIWrapper.getAgents({"mbox":"mailto:tom@example.com"});
         * XAPIWrapper.log(res);
         * >> <Person object>
         */
        getAgents(agent, callback) {
            if (this.testConfig() && agent) {
                let url = `${this.lrs.endpoint}agents?agent=${JSON.stringify(agent)}`;

                if (callback) {
                    this.defaultRequest(this.lrs, url, "GET", null, this.lrs.auth, callback, null, true, null, this.withCredentials, this.strictCallbacks);
                    return;
                }

                const conf = { url,
                    'headers': { 'Content-Type': 'application/json', 'X-Experience-API-Version': this.xapiVersion, 'Authorization': this.lrs.auth } };

                return this.asyncRequest(conf);
            }

            // Return rejected promise or error w/ callback on invalid requests
            if (callback) {
                callback('Error: invalid parameters');
            } else {
                return new Promise((res, rej) => {
                    rej('Error: invalid parameters');
                });
            }
        }

        /*
         * Update agent profile in the LRS
         * @param {object} agent   the agent this profile is related to
         * @param {string} profileid   the id you want associated with this profile
         * @param {string} profileval   the profile
         * @param {string} [matchHash]    the hash of the profile to replace or * to replace any
         * @param {string} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} false if no agent profile is included
         */
        putAgentProfile(agent, profileid, profileval, matchHash, callback) {
            if (this.testConfig()) {
                if (!profileval) return false;

                if (!matchHash || matchHash == "") matchHash = '*';

                let url = `${this.lrs.endpoint}agents/profile?agent=<agent>&profileId=<profileid>`;

                url = url.replace('<agent>', encodeURIComponent(JSON.stringify(agent)));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                let headers = { "If-Match": `"${matchHash}"` };
                if (profileval instanceof Array || profileval instanceof Object) {
                    profileval = JSON.stringify(profileval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                XHR_request(this.lrs, url, "PUT", profileval, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);
            }
        }

        /*
         * Store agent profile in the LRS
         * @param {object} agent   the agent this profile is related to
         * @param {string} profileid   the id you want associated with this profile
         * @param {string} profileval   the profile
         * @param {string} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} false if no agent profile is included
         */
        postAgentProfile(agent, profileid, profileval, callback) {
            if (this.testConfig()) {
                if (!profileval) return false;

                let url = `${this.lrs.endpoint}agents/profile?agent=<agent>&profileId=<profileid>`;

                url = url.replace('<agent>', encodeURIComponent(JSON.stringify(agent)));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                let headers = {};
                if (profileval instanceof Array || profileval instanceof Object) {
                    profileval = JSON.stringify(profileval);
                    headers["Content-Type"] = "application/json";
                } else headers["Content-Type"] = "application/octet-stream";

                XHR_request(this.lrs, url, "POST", profileval, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);
            }
        }

        /*
         * Get agnet profile from the LRS
         * @param {object} agent   the agent associated with this profile
         * @param {string} [profileid]    the id of the profile, if not included, the response will be a list of profileids
         *              associated with the agent
         * @param {object} [since]    date object or date string telling the LRS to return objects newer than the date supplied
         * @param {function} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * XAPIWrapper.getAgentProfile({"mbox":"mailto:tom@example.com"},
         *                                  "agentprofile", null,
         *                                  function(r){XAPIWrapper.log(JSON.parse(r.response));});
         * >> {info: "the agent profile"}
         */
        getAgentProfile(agent, profileid, since, callback) {
            if (this.testConfig()) {
                let url = `${this.lrs.endpoint}agents/profile?agent=<agent>`;

                url = url.replace('<agent>', encodeURIComponent(JSON.stringify(agent)));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                if (profileid) {
                    url += `&profileId=${encodeURIComponent(profileid)}`;
                }

                if (since) {
                    since = Util.isDate(since);
                    if (since != null) {
                        url += `&since=${encodeURIComponent(since.toISOString())}`;
                    }
                }

                let result = XHR_request(this.lrs, url, "GET", null, this.lrs.auth, callback, null, true, null, this.withCredentials, this.strictCallbacks);

                if (result === undefined || result.status == 404) {
                    return null;
                }

                try {
                    return JSON.parse(result.response);
                } catch (e) {
                    return result.response;
                }
            }
        }

        /*
         * Delete agent profile in the LRS
         * @param {oject} agent   the id of the Agent this profile is about
         * @param {string} profileid   the id you want associated with this profile
         * @param {string} [callback]   function to be called after the LRS responds
         *            to this request (makes the call asynchronous)
         *            the function will be passed the XMLHttpRequest object
         * @return {object} xhr response object or null if 404
         * @example
         * XAPIWrapper.deleteAgentProfile({"mbox":"mailto:tom@example.com"},
         *                                     "agentprofile");
         * >> XMLHttpRequest {statusText: "NO CONTENT", status: 204, response: "", responseType: "", responseXML: null}
         */
        deleteAgentProfile(agent, profileid, callback) {
            if (this.testConfig()) {
                let url = `${this.lrs.endpoint}agents/profile?agent=<agent>&profileId=<profileid>`;

                url = url.replace('<agent>', encodeURIComponent(JSON.stringify(agent)));
                url = url.replace('<profileid>', encodeURIComponent(profileid));

                let headers = null;
                let result = XHR_request(this.lrs, url, "DELETE", null, this.lrs.auth, callback, null, false, headers, this.withCredentials, this.strictCallbacks);

                if (result === undefined || result.status == 404) {
                    return null;
                }

                try {
                    return JSON.parse(result.response);
                } catch (e) {
                    return result;
                }
            }
        }

        asyncRequest(conf) {
            return new Promise((res, rej) => {
                request(conf, (error, resp, data) => {
                    error ? rej(error) : res({ resp, data });
                });
            });
        }

        ieRequest(method, url, headers, data) {
            let newUrl = url;

            //Everything that was on query string goes into form lets
            let formData = new Array();
            let qsIndex = newUrl.indexOf('?');
            if (qsIndex > 0) {
                formData.push(newUrl.substr(qsIndex + 1));
                newUrl = newUrl.substr(0, qsIndex);
            }

            //Method has to go on querystring, and nothing else
            newUrl = `${newUrl}?method=${method}`;

            //Headers
            if (headers !== null) {
                for (let headerName in headers) {
                    formData.push(`${headerName}=${encodeURIComponent(headers[headerName])}`);
                }
            }

            //The original data is repackaged as "content" form let
            if (data !== null) {
                formData.push(`content=${encodeURIComponent(data)}`);
            }

            return {
                "method": "POST",
                "url": newUrl,
                "headers": {},
                "data": formData.join("&")
            };
        }

        defaultRequest(lrs, url, method, data, auth, callback, callbackargs, ignore404, extraHeaders, withCredentials, strictCallbacks) {
            let xhr,
                finished = false,
                xDomainRequest = false,
                ieXDomain = false,
                ieModeRequest,
                urlparts = url.toLowerCase().match(/^(.+):\/\/([^:\/]*):?(\d+)?(\/.*)?$/),
                location = onBrowser ? window.location : "",
                urlPort,
                result,
                extended,
                prop,
                until;

            //Consolidate headers
            let headers = {};
            headers["Content-Type"] = "application/json";
            headers["Authorization"] = auth;
            headers['X-Experience-API-Version'] = this.xapiVersion;
            if (extraHeaders !== null) {
                for (let headerName in extraHeaders) {
                    headers[headerName] = extraHeaders[headerName];
                }
            }

            //See if this really is a cross domain
            xDomainRequest = location.protocol !== urlparts[1] || location.hostname !== urlparts[2];
            if (!xDomainRequest) {
                urlPort = urlparts[3] === null ? urlparts[1] === 'http' ? '80' : '443' : urlparts[3];
                xDomainRequest = urlPort === location.port;
            }

            //If it's not cross domain or we're not using IE, use the usual XmlHttpRequest
            let windowsVersionCheck = false;
            if (onBrowser) windowsVersionCheck = window.XDomainRequest && window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined;
            if (!xDomainRequest || windowsVersionCheck === undefined || windowsVersionCheck === false) {
                let options = { url, method, headers };
                if (data) options['body'] = data;
                request(options).then(requestComplete);
                // xhr = new request();
                // xhr.withCredentials = this.withCredentials;
                // xhr.open(method, url, true);
                // for(let headerName in headers)
                //     xhr.setRequestHeader(headerName, headers[headerName]);
                // Make request based on environment
                // if (onBrowser) {
                //   let options = {url, method, headers};
                //   if (data)
                //     options['body'] = data;
                //   xhr = new request(options, callback);
                // } else {
                //   // xhr = new (require('xhr2'));
                //   xhr = new XMLHttpRequest();
                //   xhr.withCredentials = withCredentials; //allow cross domain cookie based auth
                //   xhr.open(method, url, true);
                //
                //   for(let headerName in headers){
                //     xhr.setRequestHeader(headerName, headers[headerName]);
                //   }
                // }
            }
            //Otherwise, use IE's XDomainRequest object
            else {
                    ieXDomain = true;
                    ieModeRequest = ieRequest(method, url, headers, data);
                    xhr = new XDomainRequest();
                    xhr.open(ieModeRequest.method, ieModeRequest.url);
                }

            //Setup request callback
            let requestComplete = () => {
                if (!finished) {
                    // may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or
                    // onload or both might fire depending upon browser, just covering all bases with event hooks and
                    // using 'finished' flag to avoid triggering events multiple times
                    finished = true;
                    let notFoundOk = ignore404 && xhr.status === 404;
                    if (xhr.status === undefined || xhr.status >= 200 && xhr.status < 400 || notFoundOk) {
                        if (callback) {
                            if (callbackargs) {
                                strictCallbacks ? callback(null, xhr, callbackargs) : callback(xhr, callbackargs);
                            } else {
                                try {
                                    let body = JSON.parse(xhr.responseText);
                                    strictCallbacks ? callback(null, xhr, body) : callback(xhr, body);
                                } catch (e) {
                                    callback(xhr, xhr.responseText);
                                    strictCallbacks ? callback(null, xhr, body) : callback(xhr, xhr.responseText);
                                }
                            }
                        } else {
                            result = xhr;
                            return xhr;
                        }
                    } else {
                        let warning;
                        try {
                            warning = `There was a problem communicating with the Learning Record Store. ( ${xhr.status} | ${xhr.response} )${url}`;
                        } catch (ex) {
                            warning = ex.toString();
                        }
                        this.log(warning);
                        this.requestError(xhr, method, url, callback, callbackargs, strictCallbacks);
                        result = xhr;
                        return xhr;
                    }
                } else {
                    return result;
                }
            };

            // xhr.onload = requestComplete;
            // xhr.send(data);
            // xhr.onreadystatechange = () => {
            //     if (xhr.readyState === 4) {
            //        return requestComplete();
            //     }
            // };
            //
            // xhr.onload = requestComplete;
            // xhr.onerror = requestComplete;
            //
            // if (onBrowser) {
            //   xhr.send(ieXDomain ? ieModeRequest.data : data);
            // }

            // synchronous
            if (ieXDomain) {
                // synchronous call in IE, with no asynchronous mode available.
                until = 1000 + new Date();
                while (new Date() < until && xhr.readyState !== 4 && !finished) {
                    this.delay();
                }
            }
        }

        requestError(xhr, method, url, callback, callbackargs, strictCallbacks) {
            if (callback && strictCallbacks) {
                let status = xhr ? xhr.status : undefined;
                let error;
                if (status) {
                    error = new Error(`Request error: ${xhr.status}`);
                } else if (status === 0 || status === null) {
                    error = new Error('Request error: aborted');
                } else {
                    error = new Error('Request error: unknown');
                }

                if (callbackargs) {
                    callback(error, xhr, callbackargs);
                } else {
                    try {
                        let body = JSON.parse(xhr.responseText);
                        callback(error, xhr, body);
                    } catch (e) {
                        callback(error, xhr, xhr.responseText);
                    }
                }
            }
        }

        /*
         * Tests the configuration of the lrs object
         */
        testConfig() {
            return this.lrs.endpoint != undefined && this.lrs.endpoint != "";
        }

        // outputs the message to the console if available
        log(message) {
            if (!debug) return;

            console.log(message);
        }

        // iniitializes an lrs object with settings from
        // a config file and from the url query string
        getLRSObject(config) {
            let lrsProps = ["endpoint", "auth", "actor", "registration", "activity_id", "grouping", "activity_platform"];
            let lrs = new Object();
            let qslets, prop;

            qslets = this.parseQueryString();
            if (qslets !== undefined && Object.keys(qslets).length !== 0) {
                for (let i = 0; i < lrsProps.length; i++) {
                    prop = lrsProps[i];
                    if (qslets[prop]) {
                        lrs[prop] = qslets[prop];
                        delete qslets[prop];
                    }
                }
                if (Object.keys(qslets).length !== 0) {
                    lrs.extended = qslets;
                }

                lrs = this.mergeRecursive(config, lrs);
            } else {
                lrs = config;
            }

            return lrs;
        }

        // parses the params in the url query string
        parseQueryString() {
            if (!onBrowser) return {};

            let qs, pairs, pair, ii, parsed;

            qs = window.location.search.substr(1);

            pairs = qs.split('&');
            parsed = {};
            for (ii = 0; ii < pairs.length; ii++) {
                pair = pairs[ii].split('=');
                if (pair.length === 2 && pair[0]) {
                    parsed[pair[0]] = decodeURIComponent(pair[1]);
                }
            }

            return parsed;
        }

        // merges two objects
        mergeRecursive(obj1, obj2) {
            Object.assign(obj1, obj1, obj2);
            return obj1;
        }

        delay() {
            let xhr;
            let url;

            if (onBrowser) {
                xhr = new XMLHttpRequest();
                url = window.location;
            } else xhr = new XmlHttpRequest();

            url += `?forcenocache=${Util.ruuid()}`;
            xhr.open('GET', url, false);
            xhr.send(null);
        }
    }

    // // outputs the message to the console if available
    // let log = (message) => {
    //     if (!debug)
    //       return;
    //
    //     console.log(message);
    // }
    //
    // // merges two objects
    // let mergeRecursive = (obj1, obj2) => {
    //   Object.assign(obj1, obj1, obj2);
    //   return obj1;
    // };
    //
    // // iniitializes an lrs object with settings from
    // // a config file and from the url query string
    // let getLRSObject = (config) => {
    //     let lrsProps = ["endpoint","auth","actor","registration","activity_id", "grouping", "activity_platform"];
    //     let lrs = new Object();
    //     let qslets, prop;
    //
    //     qslets = parseQueryString();
    //     if (qslets !== undefined && Object.keys(qslets).length !== 0) {
    //         for (let i = 0; i<lrsProps.length; i++){
    //             prop = lrsProps[i];
    //             if (qslets[prop]){
    //                 lrs[prop] = qslets[prop];
    //                 delete qslets[prop];
    //             }
    //         }
    //         if (Object.keys(qslets).length !== 0) {
    //           lrs.extended = qslets;
    //         }
    //
    //         lrs = mergeRecursive(config, lrs);
    //     }
    //     else {
    //         lrs = config;
    //     }
    //
    //     return lrs;
    // };
    //
    // // parses the params in the url query string
    // let parseQueryString = () => {
    //     if (!onBrowser)
    //       return {};
    //
    //     let qs, pairs, pair, ii, parsed;
    //
    //     qs = window.location.search.substr(1);
    //
    //     pairs = qs.split('&');
    //     parsed = {};
    //     for ( ii = 0; ii < pairs.length; ii++) {
    //         pair = pairs[ii].split('=');
    //         if (pair.length === 2 && pair[0]) {
    //             parsed[pair[0]] = decodeURIComponent(pair[1]);
    //         }
    //     }
    //
    //     return parsed;
    // };
    //
    // let delay = () => {
    //     let xhr;
    //     let url;
    //
    //     if (onBrowser) {
    //       xhr = new XMLHttpRequest();
    //       url = window.location;
    //     }
    //     else
    //       xhr = new XmlHttpRequest();
    //
    //     url += `?forcenocache=${Util.ruuid()}`;
    //     xhr.open('GET', url, false);
    //     xhr.send(null);
    // };
    //
    // /*
    //  * formats a request in a way that IE will allow
    //  * @param {string} method   the http request method (ex: "PUT", "GET")
    //  * @param {string} url   the url to the request (ex: XAPIWrapper.lrs.endpoint + "statements")
    //  * @param {array} [headers]   headers to include in the request
    //  * @param {string} [data]   the body of the request, if there is one
    //  * @return {object} xhr response object
    //  */
    // let ie_request = (method, url, headers, data) => {
    //     let newUrl = url;
    //
    //     //Everything that was on query string goes into form lets
    //     let formData = new Array();
    //     let qsIndex = newUrl.indexOf('?');
    //     if(qsIndex > 0){
    //         formData.push(newUrl.substr(qsIndex+1));
    //         newUrl = newUrl.substr(0, qsIndex);
    //     }
    //
    //     //Method has to go on querystring, and nothing else
    //     newUrl = `${newUrl}?method=${method}`;
    //
    //     //Headers
    //     if(headers !== null){
    //         for(let headerName in headers){
    //             formData.push(`${headerName}=${encodeURIComponent(headers[headerName])}`);
    //         }
    //     }
    //
    //     //The original data is repackaged as "content" form let
    //     if(data !== null){
    //         formData.push(`content=${encodeURIComponent(data)}`);
    //     }
    //
    //     return {
    //         "method":"POST",
    //         "url":newUrl,
    //         "headers":{},
    //         "data":formData.join("&")
    //     };
    // };
    //
    // // Synchronous if callback is not provided (not recommended)
    // /*
    //  * makes a request to a server (if possible, use functions provided in XAPIWrapper)
    //  * @param {string} lrs   the lrs connection info, such as endpoint, auth, etc
    //  * @param {string} url   the url of this request
    //  * @param {string} method   the http request method
    //  * @param {string} data   the payload
    //  * @param {string} auth   the value for the Authorization header
    //  * @param {function} callback   function to be called after the LRS responds
    //  *            to this request (makes the call asynchronous)
    //  * @param {object} [callbackargs]   additional javascript object to be passed to the callback function
    //  * @param {boolean} ignore404    allow page not found errors to pass
    //  * @param {object} extraHeaders   other header key-values to be added to this request
    //  * @param {boolean} withCredentials
    //  * @param {boolean} strictCallbacks Callback must be executed and first param is error or null if no error
    //  * @return {object} xhr response object
    //  */
    // let XHR_request = (lrs, url, method, data, auth, callback, callbackargs, ignore404, extraHeaders, withCredentials, strictCallbacks) => {
    //   "use strict";
    //
    //     let xhr,
    //         finished = false,
    //         xDomainRequest = false,
    //         ieXDomain = false,
    //         ieModeRequest,
    //         urlparts = url.toLowerCase().match(/^(.+):\/\/([^:\/]*):?(\d+)?(\/.*)?$/),
    //         location = onBrowser ? window.location : "",
    //         urlPort,
    //         result,
    //         extended,
    //         prop,
    //         until;
    //
    //     //Consolidate headers
    //     let headers = {};
    //     headers["Content-Type"] = "application/json";
    //     headers["Authorization"] = auth;
    //     headers['X-Experience-API-Version'] = "1.0.3";
    //     if(extraHeaders !== null){
    //         for(let headerName in extraHeaders){
    //             headers[headerName] = extraHeaders[headerName];
    //         }
    //     }
    //
    //     //See if this really is a cross domain
    //     xDomainRequest = (location.protocol !== urlparts[1] || location.hostname !== urlparts[2]);
    //     if (!xDomainRequest) {
    //         urlPort = (urlparts[3] === null ? ( urlparts[1] === 'http' ? '80' : '443') : urlparts[3]);
    //         xDomainRequest = (urlPort === location.port);
    //     }
    //
    //     //If it's not cross domain or we're not using IE, use the usual XmlHttpRequest
    //     let windowsVersionCheck = false;
    //     if (onBrowser)
    //       windowsVersionCheck = window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined);
    //     if (!xDomainRequest || windowsVersionCheck === undefined || windowsVersionCheck===false) {
    //       // Make request based on environment
    //       if (!onBrowser) {
    //         xhr = new request({url, method, headers, body:data}, callback);
    //       } else {
    //         xhr = new XMLHttpRequest();
    //         xhr.withCredentials = withCredentials; //allow cross domain cookie based auth
    //         xhr.open(method, url, callback != null);
    //
    //         for(let headerName in headers){
    //           xhr.setRequestHeader(headerName, headers[headerName]);
    //         }
    //       }
    //     }
    //     //Otherwise, use IE's XDomainRequest object
    //     else {
    //         ieXDomain = true;
    //         ieModeRequest = ie_request(method, url, headers, data);
    //         xhr = new XDomainRequest();
    //         xhr.open(ieModeRequest.method, ieModeRequest.url);
    //     }
    //
    //     //Setup request callback
    //     let requestComplete = () => {
    //         if(!finished){
    //             // may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or
    //             // onload or both might fire depending upon browser, just covering all bases with event hooks and
    //             // using 'finished' flag to avoid triggering events multiple times
    //             finished = true;
    //             let notFoundOk = (ignore404 && xhr.status === 404);
    //             if (xhr.status === undefined || (xhr.status >= 200 && xhr.status < 400) || notFoundOk) {
    //                 if (callback) {
    //                     if(callbackargs){
    //                         strictCallbacks ? callback(null, xhr, callbackargs) : callback(xhr, callbackargs);
    //                     }
    //                     else {
    //                         try {
    //                             let body = JSON.parse(xhr.responseText);
    //                             strictCallbacks ? callback(null, xhr, body) : callback(xhr, body);
    //                         }
    //                         catch(e){
    //                             callback(xhr,xhr.responseText);
    //                             strictCallbacks ? callback(null, xhr, body) : callback(xhr, xhr.responseText);
    //                         }
    //                     }
    //                 } else {
    //                     result = xhr;
    //                     return xhr;
    //                 }
    //             } else {
    //                 let warning;
    //                 try {
    //                     warning = `There was a problem communicating with the Learning Record Store. ( ${xhr.status} | ${xhr.response} )${url}`;
    //                 } catch (ex) {
    //                     warning = ex.toString();
    //                 }
    //                 log(warning);
    //                 xhrRequestOnError(xhr, method, url, callback, callbackargs, strictCallbacks);
    //                 result = xhr;
    //                 return xhr;
    //             }
    //         } else {
    //             return result;
    //         }
    //     };
    //
    //     xhr.onreadystatechange = () => {
    //         if (xhr.readyState === 4) {
    //            return requestComplete();
    //         }
    //     };
    //
    //     xhr.onload = requestComplete;
    //     xhr.onerror = requestComplete;
    //
    //     if (onBrowser)
    //       xhr.send(ieXDomain ? ieModeRequest.data : data);
    //
    //     if (!callback) {
    //         // synchronous
    //         if (ieXDomain) {
    //             // synchronous call in IE, with no asynchronous mode available.
    //             until = 1000 + new Date();
    //             while (new Date() < until && xhr.readyState !== 4 && !finished) {
    //                 delay();
    //             }
    //         }
    //         return requestComplete();
    //     }
    // };
    //
    // /*
    //  * Holder for custom global error callback
    //  * @param {object} xhr   xhr object or null
    //  * @param {string} method   XMLHttpRequest request method
    //  * @param {string} url   full endpoint url
    //  * @param {function} callback   function to be called after the LRS responds
    //  *            to this request (makes the call asynchronous)
    //  * @param {object} [callbackargs]   additional javascript object to be passed to the callback function
    //  * @param {boolean} strictCallbacks Callback must be executed and first param is error or null if no error
    //  * @example
    //  * xhrRequestOnError = function(xhr, method, url, callback, callbackargs) {
    //  *   console.log(xhr);
    //  *   alert(xhr.status + " " + xhr.statusText + ": " + xhr.response);
    //  * };
    //  */
    // let xhrRequestOnError = (xhr, method, url, callback, callbackargs, strictCallbacks) => {
    //   if (callback && strictCallbacks) {
    //     let status = xhr ? xhr.status : undefined;
    //     let error;
    //     if (status) {
    //         error = new Error(`Request error: ${xhr.status}`);
    //     } else if (status === 0 || status === null) {
    //         error = new Error('Request error: aborted');
    //     } else {
    //         error = new Error('Request error: unknown');
    //     }
    //
    //     if (callbackargs) {
    //         callback(error, xhr, callbackargs);
    //     } else {
    //         try {
    //             let body = JSON.parse(xhr.responseText);
    //             callback(error, xhr, body);
    //         } catch (e){
    //             callback(error, xhr, xhr.responseText);
    //         }
    //     }
    //   }
    // };


    if (!onBrowser) {
        module.exports = new XAPIWrapper(Config, false);
    } else {
        window.ADL.XAPIWrapper = new XAPIWrapper(Config, false);
    }
}

{
    // adds toISOString to date objects if not there
    // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString
    if (!Date.prototype.toISOString) {
        let pad = number => {
            let r = String(number);
            if (r.length === 1) {
                r = `0${r}`;
            }
            return r;
        };

        Date.prototype.toISOString = (() => {
            return _this.getUTCFullYear() + '-' + pad(_this.getUTCMonth() + 1) + '-' + pad(_this.getUTCDate()) + 'T' + pad(_this.getUTCHours()) + ':' + pad(_this.getUTCMinutes()) + ':' + pad(_this.getUTCSeconds()) + '.' + String((_this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) + 'Z';
        })();
    }

    let onBrowser = false;
    if (typeof window !== 'undefined') {
        window.ADL = window.ADL || {};
        onBrowser = true;
    } else CryptoJS = require('crypto-js');

    class Util {
        getLang() {
            let lang;
            if (typeof navigator !== 'undefined') lang = navigator.language || navigator.browserLanguage || navigator.systemLanguage || navigator.userLanguage;else if (process && process.env) {
                let str = process.env.LANG;
                lang = str.slice(0, str.indexOf('.'));
                lang = lang.replace(/_/, '-');
            }
            return lang || "en-US";
        }

        getLangVal(langprop) {
            if (!langprop) return;

            let options = Object.keys(langprop);
            // test that langprop is a dict (obj)
            // skips if not a dict(obj) and returns
            if (options.length == 0) return undefined;

            let lang = this.getLang(),
                ret,
                dispGotten = false;

            do {
                //test and retest
                if (langprop[lang]) {
                    ret = langprop[lang];
                    dispGotten = true;
                } else if (lang.indexOf('-')) {
                    lang = lang.substring(0, lang.lastIndexOf('-'));
                }
            } while (!dispGotten && lang !== "");

            return ret;
        }

        /*!
        Excerpt from: Math.uuid.js (v1.4)
        http://www.broofa.com
        mailto:robert@broofa.com
        Copyright (c) 2010 Robert Kieffer
        Dual licensed under the MIT and GPL licenses.
        */
        ruuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                let r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : r & 0x3 | 0x8;
                return v.toString(16);
            });
        }

        /*
         * dateFromISOString
         * parses an ISO string into a date object
         * isostr - the ISO string
         */
        dateFromISOString(isostr) {
            let regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" + "([T| ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?" + "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
            let d = isostr.match(new RegExp(regexp));

            let offset = 0;
            let date = new Date(d[1], 0, 1);

            if (d[3]) {
                date.setMonth(d[3] - 1);
            }
            if (d[5]) {
                date.setDate(d[5]);
            }
            if (d[7]) {
                date.setHours(d[7]);
            }
            if (d[8]) {
                date.setMinutes(d[8]);
            }
            if (d[10]) {
                date.setSeconds(d[10]);
            }
            if (d[12]) {
                date.setMilliseconds(Number(`0.${d[12]}`) * 1000);
            }
            if (d[14]) {
                offset = Number(d[16]) * 60 + Number(d[17]);
                offset *= d[15] == '-' ? 1 : -1;
            }

            offset -= date.getTimezoneOffset();
            time = Number(date) + offset * 60 * 1000;

            let dateToReturn = new Date();
            dateToReturn.setTime(Number(time));
            return dateToReturn;
        }

        getByteLen(normal_val) {
            // Force string type
            normal_val = String(normal_val);

            let byteLen = 0;
            for (let i = 0; i < normal_val.length; i++) {
                let c = normal_val.charCodeAt(i);
                byteLen += c < 1 << 7 ? 1 : c < 1 << 11 ? 2 : c < 1 << 16 ? 3 : c < 1 << 21 ? 4 : c < 1 << 26 ? 5 : c < 1 << 31 ? 6 : Number.NaN;
            }
            return byteLen;
        }

        // shim for old-style Base64 lib
        toBase64(text) {
            if (CryptoJS && CryptoJS.enc.Base64) return CryptoJS.enc.Base64.stringify(CryptoJS.enc.Latin1.parse(text));else return Base64.encode(text);
        }

        // shim for old-style crypto lib
        toSHA1(text) {
            if (CryptoJS && CryptoJS.SHA1) return CryptoJS.SHA1(text).toString();else return Crypto.util.bytesToHex(Crypto.SHA1(text, { asBytes: true }));
        }

        toSHA256(text) {
            if (CryptoJS && CryptoJS.SHA256) return CryptoJS.SHA256(text).toString();
        }

        // check if string or object is date, if it is, return date object
        // feburary 31st == march 3rd in this solution
        isDate(date) {
            let d;
            // check if object is being passed
            if (Object.prototype.toString.call(date) === "[object Date]") d = date;else d = new Date(date);
            // deep check on date object
            if (Object.prototype.toString.call(d) === "[object Date]") {
                // it is a date
                if (isNaN(d.valueOf())) {
                    XAPIWrapper.log("Invalid date String passed");
                    return null;
                } else {
                    return d;
                }
            } else {
                // not a date
                XAPIWrapper.log("Invalid date object");
                return null;
            }
        }
    }

    if (!onBrowser) {
        module.exports = new Util();
    } else {
        window.ADL.Util = new Util();
    }
}

{

    let verbs = {
        "abandoned": {
            "id": "https://w3id.org/xapi/adl/verbs/abandoned",
            "display": { "en-US": "abandoned" }
        },
        "answered": {
            "id": "http://adlnet.gov/expapi/verbs/answered",
            "display": { "de-DE": "beantwortete",
                "en-US": "answered",
                "fr-FR": "a rpondu",
                "es-ES": "contest" }
        },
        "asked": {
            "id": "http://adlnet.gov/expapi/verbs/asked",
            "display": { "de-DE": "fragte",
                "en-US": "asked",
                "fr-FR": "a demand",
                "es-ES": "pregunt" }
        },
        "attempted": {
            "id": "http://adlnet.gov/expapi/verbs/attempted",
            "display": { "de-DE": "versuchte",
                "en-US": "attempted",
                "fr-FR": "a essay",
                "es-ES": "intent" }
        },
        "attended": {
            "id": "http://adlnet.gov/expapi/verbs/attended",
            "display": { "de-DE": "nahm teil an",
                "en-US": "attended",
                "fr-FR": "a suivi",
                "es-ES": "asisti" }
        },
        "commented": {
            "id": "http://adlnet.gov/expapi/verbs/commented",
            "display": { "de-DE": "kommentierte",
                "en-US": "commented",
                "fr-FR": "a comment",
                "es-ES": "coment" }
        },
        "completed": {
            "id": "http://adlnet.gov/expapi/verbs/completed",
            "display": { "de-DE": "beendete",
                "en-US": "completed",
                "fr-FR": "a termin",
                "es-ES": "complet" }
        },
        "exited": {
            "id": "http://adlnet.gov/expapi/verbs/exited",
            "display": { "de-DE": "verlie",
                "en-US": "exited",
                "fr-FR": "a quitt",
                "es-ES": "sali" }
        },
        "experienced": {
            "id": "http://adlnet.gov/expapi/verbs/experienced",
            "display": { "de-DE": "erlebte",
                "en-US": "experienced",
                "fr-FR": "a prouv",
                "es-ES": "experiment" }
        },
        "failed": {
            "id": "http://adlnet.gov/expapi/verbs/failed",
            "display": { "de-DE": "verfehlte",
                "en-US": "failed",
                "fr-FR": "a chou",
                "es-ES": "fracas" }
        },
        "imported": {
            "id": "http://adlnet.gov/expapi/verbs/imported",
            "display": { "de-DE": "importierte",
                "en-US": "imported",
                "fr-FR": "a import",
                "es-ES": "import" }
        },
        "initialized": {
            "id": "http://adlnet.gov/expapi/verbs/initialized",
            "display": { "de-DE": "initialisierte",
                "en-US": "initialized",
                "fr-FR": "a initialis",
                "es-ES": "inicializ" }
        },
        "interacted": {
            "id": "http://adlnet.gov/expapi/verbs/interacted",
            "display": { "de-DE": "interagierte",
                "en-US": "interacted",
                "fr-FR": "a interagi",
                "es-ES": "interactu" }
        },
        "launched": {
            "id": "http://adlnet.gov/expapi/verbs/launched",
            "display": { "de-DE": "startete",
                "en-US": "launched",
                "fr-FR": "a lanc",
                "es-ES": "lanz" }
        },
        "mastered": {
            "id": "http://adlnet.gov/expapi/verbs/mastered",
            "display": { "de-DE": "meisterte",
                "en-US": "mastered",
                "fr-FR": "a matris",
                "es-ES": "domin" }
        },
        "passed": {
            "id": "http://adlnet.gov/expapi/verbs/passed",
            "display": { "de-DE": "bestand",
                "en-US": "passed",
                "fr-FR": "a russi",
                "es-ES": "aprob" }
        },
        "preferred": {
            "id": "http://adlnet.gov/expapi/verbs/preferred",
            "display": { "de-DE": "bevorzugte",
                "en-US": "preferred",
                "fr-FR": "a prfr",
                "es-ES": "prefiri" }
        },
        "progressed": {
            "id": "http://adlnet.gov/expapi/verbs/progressed",
            "display": { "de-DE": "machte Fortschritt mit",
                "en-US": "progressed",
                "fr-FR": "a progress",
                "es-ES": "progres" }
        },
        "registered": {
            "id": "http://adlnet.gov/expapi/verbs/registered",
            "display": { "de-DE": "registrierte",
                "en-US": "registered",
                "fr-FR": "a enregistr",
                "es-ES": "registr" }
        },
        "responded": {
            "id": "http://adlnet.gov/expapi/verbs/responded",
            "display": { "de-DE": "reagierte",
                "en-US": "responded",
                "fr-FR": "a rpondu",
                "es-ES": "respondi" }
        },
        "resumed": {
            "id": "http://adlnet.gov/expapi/verbs/resumed",
            "display": { "de-DE": "setzte fort",
                "en-US": "resumed",
                "fr-FR": "a repris",
                "es-ES": "continu" }
        },
        "satisfied": {
            "id": "https://w3id.org/xapi/adl/verbs/satisfied",
            "display": { "en-US": "satisfied" }
        },
        "scored": {
            "id": "http://adlnet.gov/expapi/verbs/scored",
            "display": { "de-DE": "erreichte",
                "en-US": "scored",
                "fr-FR": "a marqu",
                "es-ES": "anot" }
        },
        "shared": {
            "id": "http://adlnet.gov/expapi/verbs/shared",
            "display": { "de-DE": "teilte",
                "en-US": "shared",
                "fr-FR": "a partag",
                "es-ES": "comparti" }
        },
        "suspended": {
            "id": "http://adlnet.gov/expapi/verbs/suspended",
            "display": { "de-DE": "pausierte",
                "en-US": "suspended",
                "fr-FR": "a suspendu",
                "es-ES": "aplaz" }
        },
        "terminated": {
            "id": "http://adlnet.gov/expapi/verbs/terminated",
            "display": { "de-DE": "beendete",
                "en-US": "terminated",
                "fr-FR": "a termin",
                "es-ES": "termin" }
        },
        "voided": {
            "id": "http://adlnet.gov/expapi/verbs/voided",
            "display": { "de-DE": "entwertete",
                "en-US": "voided",
                "fr-FR": "a annul",
                "es-ES": "anul" }
        },
        "waived": {
            "id": "https://w3id.org/xapi/adl/verbs/waived",
            "display": { "en-US": "waived" }
        }
    };

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = verbs;
    } else {
        window.ADL.verbs = verbs;
    }
}

{

    /*
     * Provides an easy constructor for xAPI agent objects
     * @param {string} identifier   One of the Inverse Functional Identifiers specified in the spec.
     *     That is, an email, a hashed email, an OpenID, or an account object.
     *     See (https://github.com/adlnet/xAPI-Spec/blob/master/xAPI.md#inversefunctional)
     * @param {string} [name]   The natural-language name of the agent
     */
    class Agent {
        constructor(identifier, name) {
            this.objectType = 'Agent';

            if (name) this.name = name;

            // figure out what type of identifier was given
            if (identifier) {
                if (identifier.mbox || identifier.mbox_sha1sum || identifier.openid || identifier.account) {
                    Object.assign(this, identifier);
                } else if (/^mailto:/.test(identifier)) {
                    this.mbox = identifier;
                } else if (/^[0-9a-f]{40}$/i.test(identifier)) {
                    this.mbox_sha1sum = identifier;
                } else if (/^http[s]?:/.test(identifier)) {
                    this.openid = identifier;
                } else if (identifier.homePage && identifier.name) {
                    this.account = identifier;
                }
            }
        }
        toString() {
            return JSON.stringify(this, null, '  ');
        }
        isValid() {
            return this.mbox || this.mbox_sha1sum || this.openid || this.account.homePage && this.account.name;
        }

        show() {
            console.log(this.toString());
        }

        getType() {
            return "Agent";
        }

        getId() {
            return this.mbox || this.openid || this.mbox_sha1sum || this.account;
        }
        getIdString() {
            let id = this.mbox || this.openid || this.mbox_sha1sum;
            if (!id && this.account) return `${this.account.homePage}:${this.account.name}`;

            return id || 'unknown';
        }
    }

    /*
     * A type of agent, can contain multiple agents
     * @param {string} [identifier]   (optional if `members` specified) See Agent.
     * @param {string} [members]    An array of Agents describing the membership of the group
     * @param {string} [name]   The natural-language name of the agent
     */
    class Group {
        constructor(identifier, members, name) {
            this.objectType = 'Group';

            // First argument is a Group object
            if (arguments.length === 1 && identifier) {
                if (identifier.member) {
                    // check for Group objects as members
                    for (let i = 0; i < identifier.member.length; i++) {
                        if (identifier.member[i].objectType == "Group" || identifier.member[i].hasOwnProperty('member')) return;
                    }
                    members = identifier.member;
                    if (identifier.name) name = identifier.name;
                } else if (identifier.name) {
                    name = identifier.name;
                } else {
                    return;
                }
            }

            if (name) this.name = name;

            if (identifier) {
                if (identifier.mbox || identifier.mbox_sha1sum || identifier.openid || identifier.account) {
                    Object.assign(this, identifier);
                } else if (/^mailto:/.test(identifier)) {
                    this.mbox = identifier;
                } else if (/^[0-9a-f]{40}$/i.test(identifier)) {
                    this.mbox_sha1sum = identifier;
                } else if (/^http[s]?:/.test(identifier)) {
                    this.openid = identifier;
                } else if (identifier.homePage && identifier.name) {
                    this.account = identifier;
                }
            }

            if (members && !this.member) this.member = members;
        }
        toString() {
            return JSON.stringify(this, null, '  ');
        }
        isValid() {
            return this.mbox || this.mbox_sha1sum || this.openid || this.account.homePage && this.account.name || this.objectType === 'Group' && this.member;
        }

        show() {
            console.log(this.toString());
        }

        getType() {
            return "Group";
        }

        getId() {
            return this.mbox || this.openid || this.mbox_sha1sum || this.account;
        }
        getIdString() {
            let id = this.mbox || this.openid || this.mbox_sha1sum;
            if (!id && this.account) return `${this.account.homePage}:${this.account.name}`;

            return id;
        }
    }

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = { Agent, Group };
    } else {
        window.ADL.Agent = Agent;
        window.ADL.Group = Group;
    }
}

{

    /*
     * Really only provides a convenient language map
     * @param {string} id   The IRI of the action taken
     * @param {string} [description]    An English-language description, or a Language Map
     */
    class Verb {
        constructor(id, description) {
            // if passed a verb object then copy and return
            if (id && id.id) {
                Object.assign(this, id);
                return;
            }

            // save id and build language map
            if (id) this.id = id;

            if (description) this.display = typeof description === 'string' || description instanceof String ? { 'en-US': description } : description;
        }
        toString() {
            return JSON.stringify(this, null, '  ');
        }
        isValid() {
            return this.id;
        }

        show() {
            console.log(this.toString());
        }

        getId() {
            return this.display ? Util.getLangVal(this.display) : this.id;
        }
    }

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = Verb;
    } else {
        window.ADL.Verb = Verb;
    }
}

{

    /*
     * Describes an object that an agent interacts with
     * @param {string} id   The unique activity IRI
     * @param {string} name   An English-language identifier for the activity, or a Language Map
     * @param {string} description   An English-language description of the activity, or a Language Map
     */
    class Activity {
        constructor(id, name, description) {
            // if first arg is activity, copy everything over
            if (id && id.id) {
                Object.assign(this, id);
                return;
            }

            this.objectType = 'Activity';
            this.id = id;

            if (name) {
                this.definition = {};
                this.definition.name = typeof name === 'string' || name instanceof String ? { 'en-US': name } : name;
            }

            if (description) {
                this.definition = this.definition || {};
                this.definition.description = typeof description === 'string' || description instanceof String ? { 'en-US': description } : description;
            }
        }
        toString() {
            return JSON.stringify(this, null, '  ');
        }
        isValid() {
            return this.id && (!this.objectType || this.objectType === 'Activity');
        }

        show() {
            console.log(this.toString());
        }

        getType() {
            return "Activity";
        }

        getId() {
            return this.id ? this.id : undefined;
        }
        getIdString() {
            return this.id ? this.id : 'unknown';
        }
    }

    /*
     * An object that refers to a separate statement
     * @param {string} id   The UUID of another statement
     */
    class StatementRef {
        constructor(id) {
            this.objectType = 'StatementRef';

            if (id && id.id) {
                Object.assign(this, id);
                return;
            }

            if (id) this.id = id;
        }
        toString() {
            return JSON.stringify(this, null, '  ');
        }
        isValid() {
            return this.id && this.objectType && this.objectType === 'StatementRef';
        }

        show() {
            console.log(this.toString());
        }

        getType() {
            return "StatementRef";
        }
    }

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = { Activity, StatementRef };
    } else {
        window.ADL.Activity = Activity;
        window.ADL.StatementRef = StatementRef;
    }
}

{

    // Require modules when using node
    if (typeof module !== 'undefined') {
        var Agent = require('./Agent').Agent;
        var Group = require('./Agent').Group;
        var Verb = require('./Verb');
        var Activity = require('./Object').Activity;
        var StatementRef = require('./Object').StatementRef;
        var Util = require('./Utils.js');
    } else {
        var Agent = window.ADL.Agent;
        var Group = window.ADL.Group;
        var Verb = window.ADL.Verb;
        var Activity = window.ADL.Activity;
        var StatementRef = window.ADL.StatementRef;
    }

    function _getobj(obj, path) {
        let parts = path.split('.');

        let part = parts[0];
        path = parts.slice(1).join('.');

        if (!obj[part]) {
            if (/\[\]$/.test(part)) {
                part = part.slice(0, -2);
                obj[part] = [];
            } else obj[part] = {};
        }

        if (!path) return obj[part];else return _getobj(obj[part], path);
    }
    /*******************************************************************************
     * Statement - a convenience class to wrap statement objects
     *
     * This sub-API is supposed to make it easier to author valid statements
     * by adding constructors and encouraging best practices. All objects in this
     * API are fully JSON-compatible, so anything expecting an statement can
     * take an improved statement and vice versa.
     *
     * A working knowledge of what exactly the LRS expects is still expected,
     * but it's easier to map an 'I did this' statement to xAPI now.
     *
     * Tech note: All constructors also double as shallow clone functions. E.g.
     *
     *   var activity1 = new Activity('A walk in the park');
     *   var activity2 = new Activity(activity1);
     *   var activity3 = new Activity(stmt_from_lrs.object);
     *
     *******************************************************************************/

    /*
     * A convenient JSON-compatible statement wrapper
     * All args are optional, but the statement may not be complete or valid
     * Can also pass an Agent IFI, Verb ID, and an Activity ID in lieu of these args
     * @param {string} [actor]   The Agent or Group committing the action described by the statement
     * @param {string} [verb]   The Verb for the action described by the statement
     * @param {string} [object]   The receiver of the action. An Agent, Group, Activity, SubStatement, or StatementRef
     * @example
     * var stmt = new Statement(
     *     'mailto:steve.vergenz.ctr@adlnet.gov',
     *    'http://adlnet.gov/expapi/verbs/launched',
     *    'http://vwf.adlnet.gov/xapi/virtual_world_sandbox'
     * );
     * >> {
     * "actor": {
     *     "objectType": "Agent",
     *     "mbox": "mailto:steve.vergenz.ctr@adlnet.gov" },
     * "verb": {
     *     "id": "http://adlnet.gov/expapi/verbs/launched" },
     * "object": {
     *     "objectType": "Activity",
     *     "id": "http://vwf.adlnet.gov/xapi/virtual_world_sandbox" }}
     */
    class Statement {
        constructor(actor = null, verb = null, object = null) {
            // if first arg is an xapi statement, parse
            if (actor && actor.actor && actor.verb && actor.object) {
                Object.assign(this, actor);
                verb = actor.verb;
                object = actor.object;
                actor = actor.actor;
            }

            this.actor = actor;
            if (actor) {
                if ((actor.objectType === 'Agent' || !actor.objectType) && !(actor instanceof Agent)) this.actor = new Agent(actor);else if (actor.objectType === 'Group' && !(actor instanceof Group)) this.actor = new Group(actor);
            }

            this.verb = verb;
            if (verb && !(verb instanceof Verb)) {
                this.verb = new Verb(verb);
            }

            // decide what kind of object was passed
            this.object = object;
            if (object) {
                if ((object.objectType === 'Activity' || !object.objectType) && !(object instanceof Activity)) {
                    this.object = new Activity(object);
                } else if (object.objectType === 'Agent' && !(object instanceof Agent)) {
                    this.object = new Agent(object);
                } else if (object.objectType === 'Group' && !(object instanceof Group)) {
                    this.object = new Group(object);
                } else if (object.objectType === 'StatementRef' && !(object instanceof StatementRef)) {
                    this.object = new StatementRef(object);
                } else if (object.objectType === 'SubStatement' && !(object instanceof SubStatement)) {
                    this.object = new SubStatement(object);
                }
            }

            this.generateId = (() => {
                this.id = Util.ruuid();
            })();
        }

        toString() {
            return `\n${JSON.stringify(this, null, '  ')}\n`;
        }

        isValid() {
            return this.actor && this.actor.isValid() && this.verb && this.verb.isValid() && this.object && this.object.isValid();
        }

        show() {
            console.log(this.toString());
        }

        generateRegistration() {
            _getobj(this, 'context').registration = Util.ruuid();
        }

        addParentActivity(activity) {
            _getobj(this, 'context.contextActivities.parent[]').push(new Activity(activity));
        }

        addGroupingActivity(activity) {
            _getobj(this, 'context.contextActivities.grouping[]').push(new Activity(activity));
        }

        addOtherContextActivity(activity) {
            _getobj(this, 'context.contextActivities.other[]').push(new Activity(activity));
        }
    }

    /*
     * A self-contained statement as the object of another statement
     * See Statement for constructor details
     * @param {string} actor   The Agent or Group committing the action described by the statement
     * @param {string} verb   The Verb for the action described by the statement
     * @param {string} object   The receiver of the action. An Agent, Group, Activity, or StatementRef
     */
    class SubStatement extends Statement {
        constructor(actor, verb, object) {
            super(actor, verb, object);
            this.objectType = 'SubStatement';

            delete this.id;
            delete this.stored;
            delete this.version;
            delete this.authority;
        }
        toString() {
            return `"${super.toString()}"`;
        }

        getType() {
            return "SubStatement";
        }
    }

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = { Statement, SubStatement };
    } else {
        window.ADL.Statement = Statement;
        window.ADL.SubStatement = SubStatement;
    }
}

{

    var ADL = obj;
    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) == variable) {
                return decodeURIComponent(pair[1]);
            }
        }
        // console.log('Query variable %s not found', variable);
    }

    function cb_wrap(cb) {
        return function () {
            var args = arguments;
            window.setTimeout(function () {
                var callerArgs = [];
                for (var i = 0; i < args.length; i++) {
                    callerArgs.push(args[i]);
                }
                cb.apply(window, callerArgs);
            }, 0);
        };
    }
    //The library will append the necessary launch info to each new A that is linked to the page.
    //NOTE: This cannot work if you programmatically change the window location. If you do, you must
    //execute the logic in setupCourseLinks to send the initialization data to the new location (if
    //you wish that new location to track as part of this session)
    function observeForNewLinks() {
        // select the target node
        var target = document.body;
        // create an observer instance
        var observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                for (var i in mutation.addedNodes) {
                    if (mutation.addedNodes[i].constructor == HTMLAnchorElement) {
                        var node = mutation.addedNodes[i];
                        setupCourseLinks([node]);
                    }
                }
            });
        });
        // configuration of the observer:
        var config = {
            attributes: true,
            childList: true,
            subtree: true
        };
        // pass in the target node, as well as the observer options
        observer.observe(target, config);
        // later, you can stop observing
        ///  observer.disconnect();
    }
    //This library will init all links in the DOM that include the attribute "courseLink = true"
    //with the information necessary for the document at that link to track as part of this session.
    function setupCourseLinks(_nodes) {
        var launchToken = getQueryVariable("xAPILaunchKey");
        var launchEndpoint = getQueryVariable("xAPILaunchService");
        var encrypted = getQueryVariable("encrypted");
        var query = "xAPILaunchKey=" + launchToken + "&xAPILaunchService=" + launchEndpoint;
        if (encrypted) {
            query += "&encrypted=true";
        }
        for (var i = 0; i < _nodes.length; i++) {
            var link = _nodes[i];
            var href = link.href;
            var courseLink = link.attributes.getNamedItem('courselink');
            if (courseLink && courseLink.value == "true") {
                if (href.indexOf("?") > -1) {
                    href = href + "&" + query;
                } else href = href + "?" + query;
                link.href = href;
            }
        };
    }

    function xAPILaunch(cb, terminate_on_unload, strict_callbacks) {
        cb = cb_wrap(cb);
        try {
            var launchToken = getQueryVariable("xAPILaunchKey");
            var launchEndpoint = getQueryVariable("xAPILaunchService");
            var encrypted = getQueryVariable("encrypted");
            if (encrypted) {
                //here, we'd have to implement decryption for the data. This makes little sense in a client side only course
            }

            xAPILaunch.terminate = function (message) {
                var launch = new URL(launchEndpoint);
                launch.pathname += "launch/" + launchToken + "/terminate";
                var xhr2 = new XMLHttpRequest();
                xhr2.withCredentials = true;
                xhr2.crossDomain = true;

                xhr2.open('POST', launch.toString(), false);
                xhr2.setRequestHeader("Content-type", "application/json");
                xhr2.send(JSON.stringify({ "code": 0, "description": message || "User closed content" }));
            };

            if (!launchToken || !launchEndpoint) return cb("invalid launch parameters");
            var launch = new URL(launchEndpoint);
            launch.pathname += "launch/" + launchToken;
            var xhr = new XMLHttpRequest();
            xhr.withCredentials = true;
            xhr.crossDomain = true;
            xhr.onerror = function (err) {
                //exit the try catch so inner execptions in the callback don't trigger this catch
                window.setTimeout(function () {
                    return cb(err);
                });
            };
            xhr.onload = function (e) {
                if (xhr.status !== 200) {
                    return xhr.onerror(xhr.responseText);
                }
                var body = JSON.parse(xhr.responseText);
                var launchData = body;

                var conf = {};
                conf['endpoint'] = launchData.endpoint;
                conf["actor"] = launchData.actor;
                conf.withCredentials = true;
                conf.strictCallbacks = strict_callbacks || false;

                window.onunload = function () {
                    if (!terminate_on_unload) return;
                    xAPILaunch.terminate("User closed content");
                };
                var wrapper = new ADL.XAPIWrapper.constructor();
                wrapper.changeConfig(conf);
                //Links that include "courseLink='true'"
                setupCourseLinks(document.body.querySelectorAll('a'));
                //Also, if links are added dynamically, we will do the same logic for those links.
                observeForNewLinks();
                return cb(null, body, wrapper);
            };
            xhr.open('POST', launch.toString(), true);
            xhr.send();
        } catch (e) {
            cb(e);
        }
    };

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = xAPILaunch;
    } else {
        window.ADL.launch = xAPILaunch;
    }
}
